@startuml
skinparam classFontSize 8
skinparam classFontName Helvetica

box "Application Task" #LightBlue
actor Application as app
participant "Provisioning API" as provisioning
participant "Provisioning Serializer (Internal)" as serializer
participant "Provisionin Parser (Internal) " as parser
participant "MQTT API" as mqtt
end box

box "Task Pool Task" #LightGreen
participant "MQTT subscription callback" as callback
end box

box "Cloud" #LightPink
participant "AWS IoT Core" as aws
end box

app -> provisioning: Call Provisioning operation.Provide\n response handling callback.
activate app

provisioning -> provisioning: Validate input arguments
provisioning --> app: Return BAD_PARAMETER for any invalid input argument

provisioning -> mqtt: Subscribe to 'accepted' and 'rejected' response topics
note right of provisioning: Register subcription callback\n for processing server response

mqtt -> aws: Transmit SUB packets to Server
mqtt -> provisioning: Return SUCCESS or error
provisioning --> app: Return MQTT_ERROR if error in subscribing

provisioning -> serializer: Calculate size of PUBLISH payload
serializer -> serializer: Performs <i>dry-run serialization</i> for size calculation
serializer -> provisioning: Return calculated size and SUCCESS of Failure
provisioning -> app: Return INTERNAL_FAILURE if calculation failed.

provisioning -> provisioning: Allocate memory for payload buffer
provisioning -> app: Return NO_MEMORY if allocation fails.

provisioning -> serializer: Request serialization of PUBLISH payload.\n Provide allocated buffer.  
serializer -> serializer: Perform <i>actual serialization</i> in buffer.
serializer -> provisioning: Return SUCCESS or INTERNAL_FAILURE/NO_MEMORY\nfor serializer failure.
provisioning -> app: Return same error code if serializalion failed.

provisioning -> mqtt: Send payload to operation's request topic
mqtt -> aws: Transmit MQTT PUBLISH packet to server
mqtt -> provisioning: Return SUCCESS or failure.
provisioning --> app: Return MQTT_ERROR if PUBLISH failed.

provisioning -> provisioning: Wait on server response with timeout.
note left of provisioning: <b>Sempahore</b> resource used for pending on\n notification from MQTT subscription callback.
alt Receive Server Response within timeout period
deactivate app
aws -> mqtt : incoming PUBLISH response packet from server
mqtt -> callback: Invoke MQTT subscription callback.\n Pass server response information.
activate callback
callback -> callback: Parse incoming PUBLISH topic for ACCEPTED/REJECTED server response.
callback -> parser: Invoke response payload parser.\n Pass accepted OR rejected response type,\n, response payload, user's response callback.
parser -> parser: Parse response payload
alt If error in parsing
parser -> callback: Return appropriate error BAD_RESPONSE, INTERNAL_FAILURE
else 
parser -> parser: Invoke user's response callback. Pass parsed payload information.
parser -> callback: Return SUCCESS.
end alt
callback -> provisioning: Notify pending API function context about server response.
note left of callback: Notification done on the shared semaphore resource.
callback -> callback: Destroy semaphore resource,\nif Provisioning libray was already cleaned.
note right of callback: Tackles RACE CONDITION between receiving\nduplicate server responses (MQTT QoS 1)\and cleaning library after API returns.
deactivate callback
activate app
else Server Response Wait Timed Out
provisioning -> provisioning: Semaphore wait timeout occurred
provisioning -> app: Return TIMEOUT error
end alt

provisioning -> mqtt: Unsubscribe from "accepted" and "rejected" response topics
mqtt -> aws: Transmit MQTT UNSUB packets to server.
mqtt -> provisioning: Return SUCCESS or error if unsubscribe failed.
provisioning -> app: Return MQTT_ERROR if unsubscribe failed.

provisioning -> provisioning: Release PUBLISH payload buffer memory.
provisioning -> app: Return SUCCESS
deactivate provisioning

@enduml