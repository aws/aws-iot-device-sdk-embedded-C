<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coreMQTT: Callback Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">coreMQTT<span id="projectnumber">&#160;v2.3.1</span>
   </div>
   <div id="projectbrief">MQTT 3.1.1 Client Library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__mqtt__callback__types.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">Callback Types</div></div>
</div><!--header-->
<div class="contents">

<p>Callback function pointer types of the MQTT library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae3bea55b0e49e5208b8c5709a5ea23aa"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mqtt__callback__types.html#gae3bea55b0e49e5208b8c5709a5ea23aa">MQTTGetCurrentTimeFunc_t</a>) (void)</td></tr>
<tr class="memdesc:gae3bea55b0e49e5208b8c5709a5ea23aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application provided function to query the time elapsed since a given epoch in milliseconds.  <br /></td></tr>
<tr class="separator:gae3bea55b0e49e5208b8c5709a5ea23aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d348277ed4fde23c95bfc749ae954a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mqtt__callback__types.html#ga00d348277ed4fde23c95bfc749ae954a">MQTTEventCallback_t</a>) (struct MQTTContext *pContext, struct MQTTPacketInfo *pPacketInfo, struct MQTTDeserializedInfo *pDeserializedInfo)</td></tr>
<tr class="memdesc:ga00d348277ed4fde23c95bfc749ae954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application callback for receiving incoming publishes and incoming acks.  <br /></td></tr>
<tr class="separator:ga00d348277ed4fde23c95bfc749ae954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227df31d6daf07e5d833537c12130167"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mqtt__callback__types.html#ga227df31d6daf07e5d833537c12130167">TransportRecv_t</a>) (<a class="el" href="group__mqtt__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, void *pBuffer, size_t bytesToRecv)</td></tr>
<tr class="memdesc:ga227df31d6daf07e5d833537c12130167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport interface for receiving data on the network.  <br /></td></tr>
<tr class="separator:ga227df31d6daf07e5d833537c12130167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a39853ff952edd715ab07b33ab2a7c5"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mqtt__callback__types.html#ga2a39853ff952edd715ab07b33ab2a7c5">TransportSend_t</a>) (<a class="el" href="group__mqtt__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, const void *pBuffer, size_t bytesToSend)</td></tr>
<tr class="memdesc:ga2a39853ff952edd715ab07b33ab2a7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport interface for sending data over the network.  <br /></td></tr>
<tr class="separator:ga2a39853ff952edd715ab07b33ab2a7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e779557b0c2db95949ef9526861dfb"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mqtt__callback__types.html#ga47e779557b0c2db95949ef9526861dfb">TransportWritev_t</a>) (<a class="el" href="group__mqtt__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, <a class="el" href="struct_transport_out_vector__t.html">TransportOutVector_t</a> *pIoVec, size_t ioVecCount)</td></tr>
<tr class="memdesc:ga47e779557b0c2db95949ef9526861dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport interface function for "vectored" / scatter-gather based writes. This function is expected to iterate over the list of vectors pIoVec having ioVecCount entries containing portions of one MQTT message at a maximum. If the proper functionality is available, then the data in the list should be copied to the underlying TCP buffer before flushing the buffer. Implementing it in this fashion will lead to sending of fewer TCP packets for all the values in the list.  <br /></td></tr>
<tr class="separator:ga47e779557b0c2db95949ef9526861dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Callback function pointer types of the MQTT library. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gae3bea55b0e49e5208b8c5709a5ea23aa" name="gae3bea55b0e49e5208b8c5709a5ea23aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3bea55b0e49e5208b8c5709a5ea23aa">&#9670;&#160;</a></span>MQTTGetCurrentTimeFunc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* MQTTGetCurrentTimeFunc_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application provided function to query the time elapsed since a given epoch in milliseconds. </p>
<dl class="section note"><dt>Note</dt><dd>The timer should be a monotonic timer. It just needs to provide an incrementing count of milliseconds elapsed since a given epoch.</dd>
<dd>
As the timer is supposed to be a millisecond timer returning a 32-bit value, it will overflow in just under 50 days. But it will not cause any issues in the library as the time function is only used for calculating durations for timeouts and keep alive periods. The difference in unsigned numbers is used where unsigned wrap around is defined. Unless the timeout is bigger than 100 days (50*2) where the numbers can wrap around more than once the code should work properly.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The time elapsed in milliseconds. </dd></dl>

</div>
</div>
<a id="ga00d348277ed4fde23c95bfc749ae954a" name="ga00d348277ed4fde23c95bfc749ae954a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d348277ed4fde23c95bfc749ae954a">&#9670;&#160;</a></span>MQTTEventCallback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* MQTTEventCallback_t) (struct MQTTContext *pContext, struct MQTTPacketInfo *pPacketInfo, struct MQTTDeserializedInfo *pDeserializedInfo)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application callback for receiving incoming publishes and incoming acks. </p>
<dl class="section note"><dt>Note</dt><dd>This callback will be called only if packets are deserialized with a result of <a class="el" href="group__mqtt__enum__types.html#ggaba7ec045874a1c3432f99173367f735ca484e062cb4f3fccc1858dd25cfeee056">MQTTSuccess</a> or <a class="el" href="group__mqtt__enum__types.html#ggaba7ec045874a1c3432f99173367f735ca25a3d1747e308e99daa805fe576f84b9">MQTTServerRefused</a>. The latter can be obtained when deserializing a SUBACK, indicating a broker's rejection of a subscribe.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Initialized MQTT context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pPacketInfo</td><td>Information on the type of incoming MQTT packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDeserializedInfo</td><td>Deserialized information from incoming packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga227df31d6daf07e5d833537c12130167" name="ga227df31d6daf07e5d833537c12130167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga227df31d6daf07e5d833537c12130167">&#9670;&#160;</a></span>TransportRecv_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* TransportRecv_t) (<a class="el" href="group__mqtt__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, void *pBuffer, size_t bytesToRecv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transport interface for receiving data on the network. </p>
<dl class="section note"><dt>Note</dt><dd>It is HIGHLY RECOMMENDED that the transport receive implementation does NOT block. coreMQTT will continue to call the transport interface if it receives a partial packet until it accumulates enough data to get the complete MQTT packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNetworkContext</td><td>Implementation-defined network context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Buffer to receive the data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytesToRecv</td><td>Number of bytes requested from the network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received or a negative value to indicate error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no data is available on the network to read and no error has occurred, zero MUST be the return value. A zero return value SHOULD represent that the read operation can be retried by calling the API function. Zero MUST NOT be returned if a network disconnection has occurred. </dd></dl>

</div>
</div>
<a id="ga2a39853ff952edd715ab07b33ab2a7c5" name="ga2a39853ff952edd715ab07b33ab2a7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a39853ff952edd715ab07b33ab2a7c5">&#9670;&#160;</a></span>TransportSend_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* TransportSend_t) (<a class="el" href="group__mqtt__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, const void *pBuffer, size_t bytesToSend)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transport interface for sending data over the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNetworkContext</td><td>Implementation-defined network context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Buffer containing the bytes to send over the network stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytesToSend</td><td>Number of bytes to send over the network.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes sent or a negative value to indicate error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no data is transmitted over the network due to a full TX buffer and no network error has occurred, this MUST return zero as the return value. A zero return value SHOULD represent that the send operation can be retried by calling the API function. Zero MUST NOT be returned if a network disconnection has occurred. </dd></dl>

</div>
</div>
<a id="ga47e779557b0c2db95949ef9526861dfb" name="ga47e779557b0c2db95949ef9526861dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e779557b0c2db95949ef9526861dfb">&#9670;&#160;</a></span>TransportWritev_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* TransportWritev_t) (<a class="el" href="group__mqtt__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, <a class="el" href="struct_transport_out_vector__t.html">TransportOutVector_t</a> *pIoVec, size_t ioVecCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transport interface function for "vectored" / scatter-gather based writes. This function is expected to iterate over the list of vectors pIoVec having ioVecCount entries containing portions of one MQTT message at a maximum. If the proper functionality is available, then the data in the list should be copied to the underlying TCP buffer before flushing the buffer. Implementing it in this fashion will lead to sending of fewer TCP packets for all the values in the list. </p>
<dl class="section note"><dt>Note</dt><dd>If the proper write functionality is not present for a given device/IP-stack, then there is no strict requirement to implement write. Only the send and recv interfaces must be defined for the application to work properly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNetworkContext</td><td>Implementation-defined network context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pIoVec</td><td>An array of TransportIoVector_t structs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ioVecCount</td><td>Number of TransportIoVector_t in pIoVec.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or a negative value to indicate error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no data is written to the buffer due to the buffer being full this MUST return zero as the return value. A zero return value SHOULD represent that the write operation can be retried by calling the API function. Zero MUST NOT be returned if a network disconnection has occurred. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
