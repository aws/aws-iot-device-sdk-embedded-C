/*
 * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * @file aws_iot_jobs_serialize.c
 * @brief Implements functions that generate and parse Jobs JSON documents.
 */

/* The config header is always included first. */
#include "iot_config.h"

/* Standard includes. */
#include <stdio.h>
#include <string.h>

/* Jobs internal include. */
#include "private/aws_iot_jobs_internal.h"

/* Error handling include. */
#include "private/iot_error.h"

/**
 * @brief The length of client tokens generated by this library.
 */
#define CLIENT_TOKEN_AUTOGENERATE_LENGTH    ( 8 )

/*-----------------------------------------------------------*/

/**
 * @brief Generate and place a client token in the given buffer.
 *
 * @param[in] pBuffer The buffer where the client token is placed.
 *
 * @warning This function does not check the length of `pBuffer`! Any provided
 * buffer must be large enough to accommodate #CLIENT_TOKEN_AUTOGENERATE_LENGTH
 * characters.
 */
static void _generateClientToken( char * pBuffer );

/**
 * @brief Generates a request JSON for a GET PENDING operation.
 *
 * @param[in] pRequestInfo Common Jobs request parameters.
 * @param[in] pOperation Operation associated with the Jobs request.
 *
 * @return #AWS_IOT_JOBS_SUCCESS or #AWS_IOT_JOBS_NO_MEMORY
 */
static AwsIotJobsError_t _generateGetPendingRequest( const AwsIotJobsRequestInfo_t * pRequestInfo,
                                                     _jobsOperation_t * pOperation );

/*-----------------------------------------------------------*/

static void _generateClientToken( char * pBuffer )
{
    /* Take the address of the given buffer, truncated to 8 characters. This
     * provides a client token that is very likely to be unique while in use. */
    uint32_t clientToken = ( uint32_t ) ( ( uint64_t ) pBuffer % 100000000ULL );

    ( void ) snprintf( pBuffer,
                       CLIENT_TOKEN_AUTOGENERATE_LENGTH + 1,
                       "%08u", clientToken );
}

/*-----------------------------------------------------------*/

static AwsIotJobsError_t _generateGetPendingRequest( const AwsIotJobsRequestInfo_t * pRequestInfo,
                                                     _jobsOperation_t * pOperation )
{
    IOT_FUNCTION_ENTRY( AwsIotJobsError_t, AWS_IOT_JOBS_SUCCESS );
    char * pJobsRequest = NULL;
    size_t copyOffset = 0;

    /* At the very least, the request will contain: {"clientToken":""} */
    size_t requestLength = AWS_IOT_CLIENT_TOKEN_KEY_LENGTH + 7;

    /* Add the length of the client token. */
    if( pRequestInfo->pClientToken != AWS_IOT_JOBS_CLIENT_TOKEN_AUTOGENERATE )
    {
        requestLength += pRequestInfo->clientTokenLength;
    }
    else
    {
        requestLength += CLIENT_TOKEN_AUTOGENERATE_LENGTH;
    }

    /* Allocate memory for the request JSON. */
    pJobsRequest = AwsIotJobs_MallocString( requestLength );

    if( pJobsRequest == NULL )
    {
        IOT_SET_AND_GOTO_CLEANUP( AWS_IOT_JOBS_NO_MEMORY );
    }

    /* Clear the request JSON. */
    ( void ) memset( pJobsRequest, 0x00, requestLength );

    /* Construct the request JSON, which consists of just a clientToken key. */
    ( void ) memcpy( pJobsRequest, "{\"", 2 );
    copyOffset = 2;

    ( void ) memcpy( pJobsRequest + copyOffset,
                     AWS_IOT_CLIENT_TOKEN_KEY,
                     AWS_IOT_CLIENT_TOKEN_KEY_LENGTH );
    copyOffset += AWS_IOT_CLIENT_TOKEN_KEY_LENGTH;

    ( void ) memcpy( pJobsRequest + copyOffset, "\":\"", 3 );
    copyOffset += 3;

    if( pRequestInfo->pClientToken == AWS_IOT_JOBS_CLIENT_TOKEN_AUTOGENERATE )
    {
        _generateClientToken( pJobsRequest + copyOffset );
        copyOffset += CLIENT_TOKEN_AUTOGENERATE_LENGTH;

        pOperation->clientTokenLength = CLIENT_TOKEN_AUTOGENERATE_LENGTH + 2;
    }
    else
    {
        ( void ) memcpy( pJobsRequest + copyOffset,
                         pRequestInfo->pClientToken,
                         pRequestInfo->clientTokenLength );
        copyOffset += pRequestInfo->clientTokenLength;

        pOperation->clientTokenLength = pRequestInfo->clientTokenLength + 2;
    }

    ( void ) memcpy( pJobsRequest + copyOffset, "\"}", 2 );

    /* Set the output parameters. */
    pOperation->pJobsRequest = pJobsRequest;
    pOperation->jobsRequestLength = requestLength;
    pOperation->pClientToken = pJobsRequest + AWS_IOT_CLIENT_TOKEN_KEY_LENGTH + 4;

    /* Ensure offsets are valid. */
    AwsIotJobs_Assert( copyOffset + 2 == requestLength );
    AwsIotJobs_Assert( pOperation->pClientToken > pOperation->pJobsRequest );
    AwsIotJobs_Assert( pOperation->pClientToken <
                       pOperation->pJobsRequest + pOperation->jobsRequestLength );

    IOT_FUNCTION_EXIT_NO_CLEANUP();
}

/*-----------------------------------------------------------*/

AwsIotJobsError_t _AwsIotJobs_GenerateJsonRequest( _jobsOperationType_t type,
                                                   const AwsIotJobsRequestInfo_t * pRequestInfo,
                                                   const AwsIotJobsUpdateInfo_t * pUpdateInfo,
                                                   _jobsOperation_t * pOperation )
{
    AwsIotJobsError_t status = AWS_IOT_JOBS_STATUS_PENDING;

    /* Generate request based on the Job operation type. */
    switch( type )
    {
        case JOBS_GET_PENDING:
            status = _generateGetPendingRequest( pRequestInfo, pOperation );
            break;

        case JOBS_START_NEXT:
            break;

        case JOBS_DESCRIBE:
            break;

        default:
            /* The only remaining valid type is UPDATE. */
            AwsIotJobs_Assert( type == JOBS_UPDATE );
            break;
    }

    return status;
}

/*-----------------------------------------------------------*/
